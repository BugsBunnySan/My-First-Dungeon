-- This file has been generated by Dungeon Editor 2.2.4

defineObject{
    name = "doctor",
    baseObject = "mummy",
    components = {
        {
			class = "Particle",
            name = "crystal",
			particleSystem = "crystal",
            enabled = false
		},
		{
			class = "Light",
			offset = vec(0,1,0),
			color = vec(39/255, 90/255, 205/255),
			range = 7,
			shadowMapSize = 128,
			castShadow = true,
			staticShadows = true,
		},
        {
            class = "Timer",
            name = "timer",
            timerInterval = 120, -- this needs to sync with cooldown of the monsterattack (there is not onCooldownReset on the attack)
            disableSelf = true,
            enabled = false,
            onActivate = function(self)
                self.go.crystal:fadeIn(2.5)                       
            end
        },
        {
            class = "MonsterAttack",
            name = "basicAttack",
            attackPower = 0,
            cooldown = 120,
            --sound = "crystal_ambient",
            animationSpeed = 0.8,
            accuracy = 100,
            onAttack = function(self)
                self.go.crystal:fadeOut(2.5)
                self.go.timer:setTimerInterval(120) -- this needs to sync with cooldown of the monsterattack (there is not onCooldownReset on the attack)
                self.go.timer:start()
                return true
            end,
            onAttackHit = function(self, champion)
                party.party:heal()
            end
        },
    }
}

defineObject{
    name = "sage_of_water",
    baseObject = "beacon_water",
    components = {
		{
			class = "Socket",     
			offset = vec(0, 0.85, -1.1),            
			onAcceptItem = function(self, item)
				return self:count() == 0
			end,
            onInit = function(self)
                self.state = "initial"                
                self.auto_inserting = false
            end,
			onInsertItem = function(self, item)
                hudPrint(self.state)
                if self.auto_inserting then
                    self.auto_inserting = false
                    return
                end
                local state_table = {
                    ["initial"] = {
                        ["flask"] = {
                            ["action"] = function(self, item)
                                             item.go:destroyDelayed()
                                             local water_flask = spawn("water_flask").item
                                             self.auto_inserting = true
                                             self:addItem(water_flask)                                              
                                             water_disciple_5.walltrigger:enable()                                           
                                        end,
                            ["new_state"] = "given_task",
                            ["message"] = "One of my disciples has lost their way, deal with them"
                        },
                        ["water_flask"] = {
                            ["action"] = nil,
                            ["new_state"] = "initial",
                            ["message"] = "To the very wise, words of wisdom are like drops of water in the ocean",
                        }
                    },
                    ["given_task"] = {
                        ["flask"] = {
                            ["action"] = function(self, item)
                                             item.go:destroyDelayed()
                                             local water_flask = spawn("water_flask").item
                                             self.auto_inserting = true
                                             self:addItem(water_flask) 
                                        end,
                            ["new_state"] = "given_task",
                            ["message"] = "To the foolish, a single word of wisdom is like the ocean"
                        },
                        ["water_flask"] = {
                            ["action"] = nil,
                            ["new_state"] = "given_task",
                            ["message"] = "To the foolish, a single word of wisdom is like the ocean"
                        },
                        ["essence_water"] = {
                            ["action"] = function(self, item)
                                sage_of_water_1_text.walltext:setWallText("Water is fluid, soft, and yielding.\nBut water will wear away rock, which is rigid and cannot yield.\nAs a rule, whatever is fluid, soft, and yielding\n will overcome whatever is rigid and hard")
                            end,
                            ["new_state"] = "task_complete",
                            ["message"] = nil
                        }
                    },
                    ["task_complete"] = {
                        ["flask"] = {
                            ["action"] = function(self, item)
                                             item.go:destroyDelayed()
                                             local water_flask = spawn("water_flask").item
                                             self.auto_inserting = true
                                             self:addItem(water_flask)                                             
                                        end,
                            ["new_state"] = "task_complete",
                            ["message"] = "Be like water my friend"
                        },
                        ["water_flask"] = {
                            ["action"] = nil,
                            ["new_state"] = "task_complete",
                            ["message"] = "To the very wise, words of wisdom are like drops of water in the ocean"
                        }                        
                    }
                }
                local state = state_table[self.state]
                local trans = state[item.go.name]
                if trans ~= nil then
                    if trans["action"] ~= nil then
                        trans["action"](self, item)
                    end
                    if trans["message"] ~= nil then
                        hudPrint(trans["message"])
                    end
                    self.state = trans["new_state"]
                end                
                hudPrint(self.state)
			end,
			--debugDraw = true,
		},
    }
}

defineObject{
    name = "disciple_of_water_trigger",
    baseObject = "beacon_furnace_head",
    components = {
        {
			class = "Particle",
            name = "splash",
			particleSystem = "frostbolt_hit",
            offset = vec(0, 1, 0),
            enabled = false
		},
		{
			class = "WallTrigger",
            name = "walltrigger",
            enabled = false,
			onActivate = function(self, entity)
                if entity.name == "water_flask" then
                    self:disable()
                    entity:destroyDelayed()
                    playSoundAt("water_hit_large", self.go.level, self.go.x, self.go.y)
                    playSoundAt("gun_shot_cannon", self.go.level, self.go.x, self.go.y)
                    spawn("mine_floor_sandpile", self.go.level, self.go.x-1, self.go.y, self.go.facing, self.go.elevation)                    
                    spawn("invisible_wall", self.go.level, self.go.x-1, self.go.y, self.go.facing, self.go.elevation)
                    self.go.model:disable()
                    self.go.eyesModel:disable()
                    self.go.leftEyeLight:disable()
                    self.go.rightEyeLight:disable()
                    self.go.splash:enable()
                    water_disciple_5_teleporter.teleporter:disable()
                    water_disciple_5_sepll_teleporter.teleporter:disable()
                    local essence_of_water = spawn("essence_water").item
                    sage_of_water.socket:addItem(essence_of_water)
                end
            end
		},
        {
			class = "ProjectileCollider",
			size = vec(2.5, 3, 0.5),
            offset = vec(0, 0, 3)
		},
    },
}

defineObject{
	name = "cannon_daemon_pilot_light",
	components = {
		{
			class = "Light",
			offset = vec(0, 0.4, 0),
			range = 0,
			color = math.saturation(vec(1, 0.5, 0.1), 0.8),
			brightness = 0,
			castShadow = true,
			shadowMapSize = 64,
			staticShadows = true,
			staticShadowDistance = 0,	-- use static shadows always
			onInit = function(self)
				-- optimization: disable casting light towards -Y
				self:setClipDistance(3, 0)
			end,
			onUpdate = function(self)
				local noise = math.noise(Time.currentTime()*3 + 123) * .5 + .9
				self:setBrightness(noise * 10)
			end,
		},
		{
			class = "Particle",
            name = "leftTorch",
			particleSystem = "torch",
			offset = vec(-0.25, 1.5, 0.25),
		},
		{
			class = "Particle",
            name = "rightTorch",
			particleSystem = "torch",
			offset = vec(0.25, 1.5, 0.25),
		},
		{
			class = "Controller",
			onActivate = function(self)
				self.go.light:enable()
				self.go.leftTorch:enable()
				self.go.rightTorch:enable()
			end,
			onDeactivate = function(self)
				self.go.light:disable()
				self.go.leftTorch:disable()
				self.go.rightTorch:disable()
			end,
			onToggle = function(self)
				if self.go.light:isEnabled() then
					self.go.light:disable()
                    self.go.leftTorch:disable()
                    self.go.rightTorch:disable()
				else
					self.go.light:enable()
                    self.go.leftTorch:enable()
                    self.go.rightTorch:enable()
				end
			end,
		},
	},
	placement = "wall",
	editorIcon = 88,
}

defineObject{
    name = "cannon_daemon",
    baseObject = "ratling_boss",
    components = {
        {
            class = "RatlingBossBrain",
            name = "brain",
            allAroundSight = true,
            onThink = function(self)
                return nil
            end,
        },
		{
			class = "MonsterAction",
			name = "alert",
			cooldown = 1000,
			animation = "alert",
			sound = "cannon_daemon_alert",
            onBeginAction = function(self) 
                self.go.muzzleFlash:restart()
                self.go.muzzleFlashLight:enable()
                self.go.muzzleFlashLight:fadeIn(0.5)
                self.go.muzzleFlashLight:fadeOut(2.5)  
            end,
		},		
        { -- repeatable alert action with low cooldown
			class = "MonsterAction",
			name = "manualAlert",
			cooldown = 2,
			animation = "alert",
			sound = "cannon_daemon_alert",
            onBeginAction = function(self) 
                self.go.muzzleFlash:restart()
                self.go.muzzleFlashLight:enable()
                self.go.muzzleFlashLight:fadeIn(0.5)
                self.go.muzzleFlashLight:fadeOut(2.5)  
            end,
		},		
        {
			class = "MonsterAttack",
			name = "rangedAttack",
			attackType = "firearm",
			attackPower = 900,
			pierce = 20,
			accuracy = 100,
			woundChance = 60,
			cooldown = 3,
			sound = "ratling_boss_attack",
			knockback = true,
			screenEffect = "damage_screen",
			cameraShake = true,
			onAttack = function(self)
				self.go.muzzleFlash:restart()
				self.go.muzzleFlashLight:enable()
				self.go.muzzleFlashLight:fadeIn(0)
				self.go.muzzleFlashLight:fadeOut(0.2)
                local facing = self.go.facing
                local from_x = self.go.x
                local from_y = self.go.y
                if facing == 0 then -- north
                    from_x = self.go.x
                    from_y = self.go.y-1
                elseif facing == 1 then -- east
                    from_x = self.go.x+1
                    from_y = self.go.y
                elseif facing == 2 then -- south
                    from_x = self.go.x
                    from_y = self.go.y+1
                elseif facing == 3 then -- west
                    from_x = self.go.x-1
                    from_y = self.go.y
                end
                spawn("fireburst", self.go.level, from_x, from_y, facing, self.go.elevation) 
			end,
		},
    },
}

defineSound{
	name = "cannon_daemon_alert",
	filename = "mod_assets/sounds/light-fuse.wav",
	loop = false,
	volume = 1,
	minDistance = 5,
	maxDistance = 12,
}